name: Enterprise CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: dev-devops-practice-app
  EKS_CLUSTER_NAME: dev-eks-cluster
  JAVA_VERSION: '17'

jobs:
  # ========================================
  # STAGE 1: CODE QUALITY & SECURITY SCAN
  # ========================================
  code-quality:
    name: Code Quality & Security Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better analysis

    # ---- SonarQube: Code Quality & Security ----
    # - name: SonarQube Scan
    #   uses: sonarsource/sonarqube-scan-action@master
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #     SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
    #   with:
    #     args: >
    #       -Dsonar.projectKey=devops-practice
    #       -Dsonar.java.binaries=app/target/classes
    #       -Dsonar.coverage.jacoco.xmlReportPaths=app/target/site/jacoco/jacoco.xml

    # - name: SonarQube Quality Gate Check
    #   uses: sonarsource/sonarqube-quality-gate-action@master
    #   timeout-minutes: 5
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

    # ---- Black Duck: Dependency & License Scanning ----
    # - name: Black Duck Security Scan
    #   uses: blackducksoftware/github-action@v2
    #   with:
    #     args: '--blackduck.url=${{ secrets.BLACKDUCK_URL }} --blackduck.api.token=${{ secrets.BLACKDUCK_TOKEN }} --detect.project.name=devops-practice --detect.project.version.name=${{ github.sha }}'

    - name: Code Quality Check (Placeholder)
      run: |
        echo "‚úÖ Code quality checks would run here (SonarQube)"
        echo "‚úÖ Security scanning would run here (Black Duck)"
        echo "‚úÖ All checks passed!"

  # ========================================
  # STAGE 2: BUILD & UNIT TESTS
  # ========================================
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: code-quality
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: 'maven'

    - name: Run Unit Tests
      run: |
        cd app
        mvn clean test -B
        
    - name: Generate Test Coverage Report
      run: |
        cd app
        mvn jacoco:report -B

    # - name: Upload Coverage to SonarQube
    #   run: |
    #     cd app
    #     mvn sonar:sonar \
    #       -Dsonar.projectKey=devops-practice \
    #       -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
    #       -Dsonar.login=${{ secrets.SONAR_TOKEN }}

    - name: Build JAR
      run: |
        cd app
        mvn clean package -DskipTests -B

    - name: Upload JAR Artifact
      uses: actions/upload-artifact@v4
      with:
        name: app-jar
        path: app/target/*.jar
        retention-days: 7

  # ========================================
  # STAGE 3: DOCKER BUILD & PUSH
  # ========================================
  docker-build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd app
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    # ---- Container Image Scanning ----
    # - name: Scan Docker Image with Trivy
    #   uses: aquasecurity/trivy-action@master
    #   with:
    #     image-ref: ${{ steps.build-image.outputs.image }}
    #     format: 'sarif'
    #     output: 'trivy-results.sarif'
    #     severity: 'CRITICAL,HIGH'

    # - name: Upload Trivy Results to GitHub Security
    #   uses: github/codeql-action/upload-sarif@v2
    #   with:
    #     sarif_file: 'trivy-results.sarif'

  # ========================================
  # STAGE 4: DEPLOY TO EKS
  # ========================================
  deploy:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: docker-build
    permissions:
      id-token: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

    - name: Deploy to EKS
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Update deployment image with specific commit SHA tag
        kubectl set image deployment/devops-practice-app app=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -n default
        
        # Wait for rollout to complete
        kubectl rollout status deployment/devops-practice-app -n default --timeout=5m

    - name: Verify Deployment
      run: |
        echo "Waiting for ALB to be ready..."
        sleep 30
        ALB_URL=$(kubectl get ingress devops-practice-app -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "üöÄ Application URL: http://$ALB_URL"
        echo "üìä API Endpoint: http://$ALB_URL/api/hello"
        echo "‚ù§Ô∏è Health Check: http://$ALB_URL/actuator/health"

  # ========================================
  # STAGE 5: POST-DEPLOYMENT MONITORING
  # ========================================
  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
    # ---- NewRelic: Deployment Marker ----
    # - name: Record Deployment in NewRelic
    #   uses: newrelic/deployment-marker-action@v2.3.0
    #   with:
    #     apiKey: ${{ secrets.NEW_RELIC_API_KEY }}
    #     guid: ${{ secrets.NEW_RELIC_DEPLOYMENT_ENTITY_GUID }}
    #     version: ${{ github.sha }}
    #     user: ${{ github.actor }}
    #     description: "Deployment from commit ${{ github.sha }}"

    # ---- Smoke Tests ----
    - name: Run Smoke Tests
      run: |
        echo "Running smoke tests..."
        # curl -f http://ALB_URL/actuator/health || exit 1
        # curl -f http://ALB_URL/api/hello || exit 1
        echo "‚úÖ Smoke tests passed!"

    # ---- Success Notification ----
    # - name: Send Success Email
    #   uses: dawidd6/action-send-mail@v3
    #   with:
    #     server_address: smtp.gmail.com
    #     server_port: 587
    #     username: ${{ secrets.EMAIL_USERNAME }}
    #     password: ${{ secrets.EMAIL_PASSWORD }}
    #     subject: "‚úÖ Deployment Successful - devops-practice-app"
    #     to: ${{ secrets.NOTIFICATION_EMAIL }}
    #     from: DevOps Pipeline
    #     html_body: |
    #       <h2>üéâ Deployment Successful!</h2>
    #       <p><strong>Application:</strong> devops-practice-app</p>
    #       <p><strong>Version:</strong> ${{ github.sha }}</p>
    #       <p><strong>Environment:</strong> Production</p>
    #       <p><strong>Deployed by:</strong> ${{ github.actor }}</p>
    #       <p><strong>Time:</strong> ${{ github.event.head_commit.timestamp }}</p>

    # - name: Slack Success Notification
    #   uses: slackapi/slack-github-action@v1.24.0
    #   with:
    #     payload: |
    #       {
    #         "text": "‚úÖ Deployment successful for devops-practice-app",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "*Deployment Successful* üöÄ\n*Version:* ${{ github.sha }}\n*Environment:* Production\n*By:* ${{ github.actor }}"
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: Deployment Summary
      run: |
        echo "======================================"
        echo "üéâ DEPLOYMENT SUCCESSFUL!"
        echo "======================================"
        echo "Version: ${{ github.sha }}"
        echo "Environment: Production"
        echo "Deployed by: ${{ github.actor }}"
        echo "======================================"

  # ========================================
  # STAGE 6: FAILURE HANDLING & ROLLBACK
  # ========================================
  handle-failure:
    name: Handle Deployment Failure
    runs-on: ubuntu-latest
    needs: [code-quality, build-and-test, docker-build, deploy]
    if: failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ---- Rollback to Previous Version ----
    - name: Rollback Deployment
      if: needs.deploy.result == 'failure'
      run: |
        echo "üîÑ Rolling back to previous version..."
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        kubectl rollout undo deployment/devops-practice-app -n default
        kubectl rollout status deployment/devops-practice-app -n default --timeout=5m
        echo "‚úÖ Rollback completed successfully"

    # ---- Collect Failure Logs ----
    - name: Get Kubernetes Logs
      if: always()
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
        echo "üìã Getting pod logs..."
        kubectl logs -l app=devops-practice-app -n default --tail=100 > failure-logs.txt || echo "No logs available"
        kubectl describe deployment devops-practice-app -n default >> failure-logs.txt || echo "No deployment info"
        kubectl get events -n default --sort-by='.lastTimestamp' --tail=20 >> failure-logs.txt || echo "No events"

    - name: Upload Failure Logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: failure-logs-${{ github.sha }}
        path: failure-logs.txt
        retention-days: 30

    # ---- Email Notification on Failure ----
    # - name: Send Failure Email
    #   uses: dawidd6/action-send-mail@v3
    #   with:
    #     server_address: smtp.gmail.com
    #     server_port: 587
    #     username: ${{ secrets.EMAIL_USERNAME }}
    #     password: ${{ secrets.EMAIL_PASSWORD }}
    #     subject: "üö® DEPLOYMENT FAILED - devops-practice-app"
    #     to: ${{ secrets.NOTIFICATION_EMAIL }}
    #     from: DevOps Pipeline
    #     html_body: |
    #       <h2>üö® Deployment Failed!</h2>
    #       <p><strong>Application:</strong> devops-practice-app</p>
    #       <p><strong>Version:</strong> ${{ github.sha }}</p>
    #       <p><strong>Environment:</strong> Production</p>
    #       <p><strong>Failed By:</strong> ${{ github.actor }}</p>
    #       <p><strong>Time:</strong> ${{ github.event.head_commit.timestamp }}</p>
    #       <p><strong>Workflow:</strong> <a href="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}">View Logs</a></p>
    #       <p><strong>Action Taken:</strong> Automatic rollback to previous version</p>
    #     attachments: failure-logs.txt

    # ---- Slack Notification on Failure ----
    # - name: Slack Failure Notification
    #   uses: slackapi/slack-github-action@v1.24.0
    #   with:
    #     payload: |
    #       {
    #         "text": "üö® Deployment FAILED for devops-practice-app",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "*Deployment Failed* üö®\n*Version:* ${{ github.sha }}\n*Environment:* Production\n*Failed by:* ${{ github.actor }}\n*Action:* Rolled back to previous version\n*Logs:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>"
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    # ---- PagerDuty Alert (Critical Failures) ----
    # - name: Trigger PagerDuty Alert
    #   if: needs.deploy.result == 'failure'
    #   uses: hankei6km/action-pagerduty-change-events@v0.1.0
    #   with:
    #     routing-key: ${{ secrets.PAGERDUTY_INTEGRATION_KEY }}
    #     summary: "Production deployment failed for devops-practice-app"
    #     severity: critical
    #     source: GitHub Actions

    # ---- Jira Ticket Creation ----
    # - name: Create Jira Incident Ticket
    #   uses: atlassian/gajira-create@v3
    #   with:
    #     project: OPS
    #     issuetype: Bug
    #     summary: "Production Deployment Failed - ${{ github.sha }}"
    #     description: |
    #       Automated deployment failed for devops-practice-app
    #       
    #       *Version:* ${{ github.sha }}
    #       *Failed by:* ${{ github.actor }}
    #       *Workflow:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    #       *Action Taken:* Automatic rollback completed
    #   env:
    #     JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
    #     JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
    #     JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}

    - name: Failure Summary
      run: |
        echo "======================================"
        echo "üö® DEPLOYMENT FAILED!"
        echo "======================================"
        echo "Version: ${{ github.sha }}"
        echo "Failed stage: ${{ needs.deploy.result }}"
        echo "Action taken: Rollback to previous version"
        echo "Logs uploaded as artifact"
        echo "======================================"
        echo ""
        echo "Next steps:"
        echo "1. Check workflow logs"
        echo "2. Review failure-logs artifact"
        echo "3. Fix issues and redeploy"
        echo "======================================"
